<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/env ruby

$: &lt;&lt; ENV['TM_BUNDLE_SUPPORT']
$: &lt;&lt; ENV['TM_SUPPORT_PATH']

require "enumerator"
require 'lib/markdownhelpers'
require 'lib/escape'

# get the list itself in a nice array
listtxt = $stdin.read()
indent, numbered, spaced, nextitemregex = Markdown.get_list_type(listtxt)
list = Markdown.split_list(listtxt, nextitemregex)

# now we need to figure out where we were when we hit enter
offsetline = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i()
index = ENV['TM_LINE_INDEX'].to_i()

# split the appropriate entry
list.each_index() do |i|
	if list[i][0][0] &lt;= offsetline and (i == (list.length() - 1) or list[i+1][0][0] &gt; offsetline)
		# the breakline and the indent determine where the cursor was when enter was hit
		# if the cursor was on a subline of a multi-line entry, then we don't need to account
		# for the initial indent the bullet or numbers gave it
		breakline = offsetline - list[i][0][0]
		lineindent = (if breakline == 0 then list[i][0][1] else -1 end)

		# we run into some issues with the convenience slicing functions
		# if it is negative, then the end point is assumed to be counted
		# from the end of the array.  That means we have to litter this with
		# functional if statements to avoid that case
		firstpart = (if breakline &gt; 0 then list[i][1].to_a()[0..breakline-1].join() else "" end)
		firstpart = firstpart + (if (index-lineindent-2) &lt;= 0 then "" else (list[i][1].to_a()[breakline][0..(index-lineindent-2)]) end)

		secondpart = list[i][1].to_a()[breakline][[index-lineindent-1,0].max()..-1] + list[i][1].to_a()[breakline+1..-1].join()
		list = ((if i == 0 then [] else list[0..i-1].map { |l| e_sn(l[1]) } end) + [e_sn(firstpart), "$0" + e_sn(secondpart[/^\s*(.*)/,1])] + list[i+1..-1].map { |l| e_sn(l[1]) })
 		break
	end
end

if spaced
	if numbered
		print(list.enum_with_index.map { |v, i| "#{indent}#{(i + 1)}. #{v}" }.join("\n\n"))
	else
		print(list.map { |v| "#{indent}* #{v}" }.join("\n\n"))
	end
else
	if numbered
		print list.enum_with_index.map { |v, i| "#{indent}#{(i + 1)}. #{v}" }.join("\n")
	else
		print list.map { |v| "#{indent}* #{v}" }.join("\n")
	end
end
</string>
	<key>fallbackInput</key>
	<string>scope</string>
	<key>input</key>
	<string>selection</string>
	<key>keyEquivalent</key>
	<string></string>
	<key>name</key>
	<string>Add List Item</string>
	<key>output</key>
	<string>insertAsSnippet</string>
	<key>scope</key>
	<string>markup.list</string>
	<key>uuid</key>
	<string>622F0B69-EB98-4EB9-8DC8-2AC56FF2501E</string>
</dict>
</plist>
